'use client';

import React, { useState } from 'react';
import { Node, Edge } from '@xyflow/react';
import { toast } from 'sonner';

interface WorkflowManagerProps {
  nodes: Node[];
  edges: Edge[];
  onSaveWorkflow: () => void;
  onSaveWorkflowToBackend: () => void;
  onLoadWorkflow: (workflowData: any) => void;
  workflowId?: string | null;
  workflowName: string;
  onDeploymentComplete?: () => void;
  onDeploymentStatusChange?: (isDeploying: boolean) => void;
  onSaveStatusChange?: (isSaving: boolean) => void;
  onSaveComplete?: () => void;
  onWorkflowNameChange?: (name: string) => void;
  onWorkflowIdChange?: (id: string | null) => void;
}

export default function WorkflowManager({
  nodes,
  edges,
  onSaveWorkflow,
  onSaveWorkflowToBackend,
  onLoadWorkflow,
  workflowId,
  workflowName,
  onDeploymentComplete,
  onDeploymentStatusChange,
  onSaveStatusChange,
  onSaveComplete,
  onWorkflowNameChange,
  onWorkflowIdChange
}: WorkflowManagerProps) {
  const [isDeploying, setIsDeploying] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const buildWorkflowPayload = () => {
    const workflowData = {
      nodes: nodes.map(node => ({
        id: node.id,
        type: node.type,
        position: node.position,
        data: node.data
      })),
      edges: edges.map(edge => ({
        id: edge.id,
        source: edge.source,
        target: edge.target,
        sourceHandle: edge.sourceHandle,
        targetHandle: edge.targetHandle
      })),
      timestamp: new Date().toISOString(),
      name: (workflowName?.trim() && workflowName.trim() !== "Untitled Workflow") ? workflowName.trim() : "" // Empty name triggers auto-generation on backend (Untitled 1, 2, etc.)
    };
    return workflowData;
  };

  const handleSaveWorkflow = () => {
    const workflowData = buildWorkflowPayload();

    // Create and download JSON file
    const jsonString = JSON.stringify(workflowData, null, 2);
    const blob = new Blob([jsonString], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    const link = document.createElement('a');
    link.href = url;
    link.download = `${workflowData.name}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    
    toast.success('Workflow saved as JSON file!');
  };

  const handleSaveWorkflowToBackend = async () => {
    // Prevent multiple saves at once
    if (isSaving) {
      toast.error('Save already in progress. Please wait...');
      return;
    }

    setIsSaving(true);
    if (onSaveStatusChange) {
      onSaveStatusChange(true);
    }

    try {
      const payload = buildWorkflowPayload();
      const API_BASE = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000';
      
      // If workflowId exists, update existing workflow; otherwise create new one
      if (workflowId) {
        // Update existing workflow - only send data, not name (to preserve existing name)
        const res = await fetch(`${API_BASE}/api/v1/workflows/${workflowId}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ data: { nodes: payload.nodes, edges: payload.edges } })
        });
        if (!res.ok) {
          const t = await res.text();
          throw new Error(`Failed to update workflow: ${res.status} ${t}`);
        }
        toast.success('Workflow updated successfully');
      } else {
        // Create new workflow - name will be auto-generated by backend
        const res = await fetch(`${API_BASE}/api/v1/workflows/`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: payload.name, data: { nodes: payload.nodes, edges: payload.edges } })
        });
        if (!res.ok) {
          const t = await res.text();
          throw new Error(`Failed to save workflow: ${res.status} ${t}`);
        }
        const data = await res.json();
        
        // Update URL to include workflow ID so future saves update instead of creating new
        if (data?.data?.id) {
          window.history.replaceState({}, '', `/workflow?id=${data.data.id}`);
          // Update workflowId state via callback
          onWorkflowIdChange?.(data.data.id);
          // Trigger a URL check by dispatching a custom event
          window.dispatchEvent(new PopStateEvent('popstate'));
        }
        if (data?.data?.name) {
          onWorkflowNameChange?.(data.data.name);
        }
        
        toast.success('Workflow saved successfully');
      }
      
      // Notify that save is complete (always call this)
      if (onSaveComplete) {
        onSaveComplete();
      }
    } catch (e) {
      toast.error(e instanceof Error ? e.message : 'Failed to save workflow');
    } finally {
      // Always reset saving state
      setIsSaving(false);
      if (onSaveStatusChange) {
        onSaveStatusChange(false);
      }
    }
  };

  const handleDeployWorkflow = async () => {
    // Prevent multiple deployments at once
    if (isDeploying) {
      toast.error('Deployment already in progress. Please wait...');
      return;
    }

    setIsDeploying(true);
    if (onDeploymentStatusChange) {
      onDeploymentStatusChange(true);
    }

    const loadingToast = toast.loading('Preparing deployment...');

    try {
      const payload = buildWorkflowPayload();
      const API_BASE = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000';

      let currentWorkflowId = workflowId;

      // Step 1: Creating/updating snapshot
      toast.loading('Creating workflow snapshot...', { id: loadingToast });
      await new Promise(resolve => setTimeout(resolve, 800));

      // Save or update workflow
      if (!currentWorkflowId) {
        // Create new workflow - name will be auto-generated by backend
        const saveRes = await fetch(`${API_BASE}/api/v1/workflows/`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: payload.name, data: { nodes: payload.nodes, edges: payload.edges } })
        });
        if (!saveRes.ok) {
          const t = await saveRes.text();
          throw new Error(`Failed to save workflow: ${saveRes.status} ${t}`);
        }
        const saved = await saveRes.json();
        currentWorkflowId = saved?.data?.id;
        if (!currentWorkflowId) throw new Error('No workflow ID returned from backend');
        if (saved?.data?.name) {
          onWorkflowNameChange?.(saved.data.name);
        }
        
        // Update URL with new workflow ID (without reload to preserve canvas state)
        window.history.replaceState({}, '', `/workflow?id=${currentWorkflowId}`);
        // Update workflowId state via callback
        onWorkflowIdChange?.(currentWorkflowId);
      } else {
        // Update existing workflow - only send data, not name (to preserve existing name)
        const updateRes = await fetch(`${API_BASE}/api/v1/workflows/${currentWorkflowId}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ data: { nodes: payload.nodes, edges: payload.edges } })
        });
        if (!updateRes.ok) {
          const t = await updateRes.text();
          throw new Error(`Failed to update workflow: ${updateRes.status} ${t}`);
        }
      }

      // Step 2: Validating workflow
      toast.loading('Validating workflow configuration...', { id: loadingToast });
      await new Promise(resolve => setTimeout(resolve, 600));

      // Step 3: Checking deployment status
      toast.loading('Checking deployment status...', { id: loadingToast });
      await new Promise(resolve => setTimeout(resolve, 500));

      // Check if deployment already exists for this workflow
      const checkRes = await fetch(`${API_BASE}/api/v1/deployments/workflow/${currentWorkflowId}`);
      const checkData = await checkRes.json();
      const isUpdate = checkData.success && checkData.data !== null;

      // Step 4: Deploy/Update
      toast.loading(isUpdate ? 'Updating deployment...' : 'Creating deployment...', { id: loadingToast });
      await new Promise(resolve => setTimeout(resolve, 700));

      // Create or update deployment
      const depRes = await fetch(`${API_BASE}/api/v1/deployments/`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ workflow_id: currentWorkflowId })
      });
      if (!depRes.ok) {
        const t = await depRes.text();
        throw new Error(`Failed to deploy workflow: ${depRes.status} ${t}`);
      }
      const dep = await depRes.json();
      const depId = dep?.data?.id;
      const wasUpdated = dep?.data?.updated;
      const invokePath = dep?.data?.invoke_url;
      const fullUrl = `${API_BASE}${invokePath || `/api/v1/deployments/${depId}/invoke`}`;

      // Step 5: Finalizing
      toast.loading('Finalizing...', { id: loadingToast });
      await new Promise(resolve => setTimeout(resolve, 500));

      await navigator.clipboard?.writeText(fullUrl).catch(() => {});

      const successMessage = wasUpdated
        ? 'Deployment updated! Invoke URL copied to clipboard'
        : 'Deployed! Invoke URL copied to clipboard';
      toast.success(successMessage, { id: loadingToast });
      
      // Immediately trigger deployment status update (no delay needed)
      if (onDeploymentComplete) {
        onDeploymentComplete();
      }
    } catch (e) {
      toast.error(e instanceof Error ? e.message : 'Failed to deploy workflow', { id: loadingToast });
    } finally {
      // Always reset deploying state
      setIsDeploying(false);
      if (onDeploymentStatusChange) {
        onDeploymentStatusChange(false);
      }
    }
  };

  const handleUploadWorkflow = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const workflowData = JSON.parse(e.target?.result as string);
        onLoadWorkflow(workflowData);
        toast.success('Workflow loaded successfully!');
      } catch (error) {
        toast.error('Invalid JSON file! Please select a valid workflow file.');
      }
    };
    reader.readAsText(file);
    
    // Reset the input
    event.target.value = '';
  };

  return {
    handleSaveWorkflow,
    handleSaveWorkflowToBackend,
    handleUploadWorkflow,
    handleDeployWorkflow,
    isDeploying,
    isSaving
  };
}
